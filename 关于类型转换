一
byte 1字节 char两字节  int 4字节 float4字节  long 8字节
除了char以外都是有符号的 char从\u0000-\uffff
二类型转化
低位转高位 一律是有符号扩展位数 如果是整数全部补0 负数全部补1 这样保证了低转高数值不变
如果要保证低位不变,高位也不变 则可以 和0xff按位&运算

高位转低位 就是截取 

但是要注意截取的是二进制的补码 而不是源码  正的源码=补码 负的源码\反码\补码不一样
按位运算的对象也是补码 截取之后赋值也是补码形式  

比如-129 转换成byte
-129 源码 10000000 00000000 00000000 10000001
     反码 11111111 11111111 11111111 01111110
     补码 11111111 11111111 11111111 01111111
     
     所以截取之后 是01111111 这个数字复制给byte是127
     
     
     如果是比较大的数字(比如8515或者-15891)不好写二进制 可以先%256取余数 然后再把余数写成32位二进制补码(正数源码=补码)形式 然后截取赋值
     但是要注意的一点是 由于截取后的值也是补码形式,所以如果最高位是1(负数) 要先转化成原码再读取,如果最高位是0,则直接读取
     
     
     注意正负数区别.....写源码的时候不能搞混了 
