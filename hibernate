框架:软件的半成品,可能已经完成了部分你需要的功能,将我们复杂的功能封装了起来 
Hibernate:
Hibernate是一个开放源代码的对象关系映射框架，它对JDBC进行了非常轻量级的对象封装，它将POJO与数据库表建立映射关系，是一个全自动的orm框架
，hibernate可以自动生成SQL语句，自动执行，使得Java程序员可以随心所欲的使用对象编程思维来操纵数据库。 Hibernate可以应用在任何使用JDBC的场合，
既可以在Java的客户端程序使用，也可以在Servlet/JSP的Web应用中使用，最具革命意义的是，Hibernate可以在应用EJB的JaveEE架构中取代CMP，
完成数据持久化的重任。


入门
ORM:对象关系映射 将java中的类和数据库中的表对应起来

下载hibernate开发环境
使用需要  数据库的驱动包  hibernate必须包  c3p0包    日志包

使用过程:
1创建javabean
2创建表  
3创建映射  通过XML配置来完成  统一命名规范  类名.hbm.xml  位置一般和类在一个位置
这个xml有一个约束(约束是对xml里面标签的一个约束)  这个约束可以在core包里面去找 具体在core的第一个文件夹得最后面
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
    
这个约束是指这个xml里面应该有什么样子的标签  只要引入了这个约束 那么xml里只能创建约束中规定的标签
<?xml version="1.0" encoding="UTF-8"?>     class标签用来创建表与类的映射  里面的子标签id用来创建主键与对应列的映射  property用来普通属性的映射
<!DOCTYPE hibernate-mapping PUBLIC 
    "-//Hibernate/Hibernate Mapping DTD 3.0//EN"
    "http://www.hibernate.org/dtd/hibernate-mapping-3.0.dtd">
   <hibernate-mapping>
   <class name="com.study.hibernate.Customer" table="cst_customer">
   <id name="cust_id" column="cust_id">
   <generator class="native"></generator>
   </id>
   <property name="cust_name" column="cust_name"></property>
   <property name="cust_source" column="cust_source"></property>
   <property name="cust_industry" column="cust_industry"></property>
   <property name="cust_level" column="cust_level"></property>
   <property name="cust_phone" column="cust_phone"></property>
   <property name="cust_mobile" column="cust_mobile"></property>
   </class>
   </hibernate-mapping>   如果类名和表名一致则可以省略table标签 如果属性名和表列名字一样则可以省略colume
     
   4创建hibernate的核心配置文件  hibernate.cfg.xml  在src下创建
   同样的 也得有约束  约束在core第一个文件夹中的最后confg中
   这个xml用来配置和数据库相关的东西以及配置hibernate方言 dialect  比如 加载驱动 数据库名字密码 
   这个方言是指是以mysql的语法形式生成sql语句
   
   <?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE hibernate-configuration PUBLIC
	"-//Hibernate/Hibernate Configuration DTD 3.0//EN"
	"http://www.hibernate.org/dtd/hibernate-configuration-3.0.dtd">
	<hibernate-configuration>
	<session-factory>
	<property name="hibernate.connection.driver_class">com.mysql.jdbc.Driver.</property>
	<property name="hibernate.connection.url">jdbc:mysql://localhost:3306/hibernate_</property>
	<property name="hibernate.connection.username">root</property>
	<property name="hibernate.connection.password">root</property>
	<property name="hibernate.dialect">org.hibernate.dialect.MySQLDialect</property>
  <mapping resource="路径com/study/hibernate/Customer.hbm.xml"/>  这个mapping是引入我们建立好的映射 也就是hbm 路径用/分开 相对路径
  <property name="hibernate.show_sql"></property>   控制台显示sql语句
  <property name="hibernate.format_sql"></property>  格式化
  <property name="hibernate.hbm2ddl.auto"></property>  自动创建表 常用 update(如果没有则会创建和更新) validate(校验表名和类名是否存在)
  </session-factory>
	</hibernate-configuration>
   
   关于不同数据库的属性名字可以在hibernateproject文件的etc的hibernateproperties中查看
   
   在java中使用
   1加载hibernate核心配置文件
   configuration con=....new configuration.configure()   configure这个函数默认以hibernate.cfg.xml为配置文件 也可以指定参数
   
   可以分开写 configuration configutation= new configuration();
              configuration.configure();
   
   一般来说在核心配置文件mapping标签加载了映射文件 如果标签中没有 
   则手动加载映射: configuration.addresource("映射文件相对路径");
   
   2创建sessionfactory对象  类似于数据库连接池
    configuretion.buildsessionFactory();
   3获取session  相当于一次和数据库的连接
   sessionFacrory.openSession()
   4手动开启事务  hibernate5中不需要手动开启
   session.begintransaction()
   5编写代码...
   
   6
   transaction.commit();
   session.close();
   
   实际上前面几步可以放在一个工具类中
   
   
   二如何引入本地dtd文件约束xml(在没有联网的情况下xml没有提示)
   1、window --> preferencrs --> xml --> xml catalog --> add
   2、location 选择 file system，然后选择你的本地dtd文件。
   3、key type 选择uri。
   4、key 填入 我们使用的外部dtd来源的uri
   
   
   三sessionfactory
     内部维护了hiberbate的连接池  和二级缓存(已经不用了)  它是线程安全的
     
     如果不想用sessionfactory的内置连接池 那么可以使用c3p0  在hibernate的核心配置文件(hibernate.cfg.xml)中引入property  然后导入c3p0jar包
     <!-- 配置C3P0连接池 -->
		<property name="connection.provider_class">org.hibernate.connection.C3P0ConnectionProvider</property>
		<!--在连接池中可用的数据库连接的最少数目 -->
		<property name="c3p0.min_size">5</property>
		<!--在连接池中所有数据库连接的最大数目  -->
		<property name="c3p0.max_size">20</property>
		<!--设定数据库连接的过期时间,以秒为单位,
		如果连接池中的某个数据库连接处于空闲状态的时间超过了timeout时间,就会从连接池中清除 -->
		<property name="c3p0.timeout">120</property>
		 <!--每3000秒检查所有连接池中的空闲连接 以秒为单位-->
		<property name="c3p0.idle_test_period">3000</property>
    
     
    为了只在一个项目中生成一个sessionfactory  可以做一个工具类 然后对外暴露一个返回session(一次连接)的静态方法 
    为了只创建一次sessionfactory 可以在静态代码块中实现
     
     
     工具类
     public class HibernateUtil{
      public static final configuration cfg;
      public static final sessinFactory  sf;
      
      static{
        cfg = new configuration().configure();
        sf  = cfg.buildsessionfactory();
      }
        public static Session getSession(){
            return sf.openSession();
        }
     }
    
     
     
     
     
 四log4j的使用方法,只需要将log4j的属性文件放在src下即可(log4加.properties)
               ### direct log messages to stdout ###
          log4j.appender.stdout=org.apache.log4j.ConsoleAppender
          log4j.appender.stdout.Target=System.err
          log4j.appender.stdout.layout=org.apache.log4j.PatternLayout
          log4j.appender.stdout.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n

          ### direct messages to file mylog.log ###
          log4j.appender.file=org.apache.log4j.FileAppender
          log4j.appender.file.File=c\:mylog.log
          log4j.appender.file.layout=org.apache.log4j.PatternLayout
          log4j.appender.file.layout.ConversionPattern=%d{ABSOLUTE} %5p %c{1}:%L - %m%n

          ### set log levels - for more verbose logging change 'info' to 'debug' ###
          # error warn info debug trace
          log4j.rootLogger= info, stdout ,file

五 session (相当于连接) 非线程安全 
非线程安全意味着对象不能当成员变量申明 只能局部变量
session中的方法
save  保存  将对象保存到表
查询 只能以主键为条件查询
get(class c, serializable id);
load(class c, serializable id)

get和load的区别?

 get是在执行函数的时候就发送查询并得到结果
 load是懒加载,  在调用load的时候并不会直接返回结果而是返回一个代理对象
 只有当真正使用这个对象的时候才发送查询语句
  
  修改方法:
  1直接创建对象 然后修改
  是一种覆盖的方式
  session.update();
  2查询之后再修改
  先通过get得到customer  然后再该相应的属性  再更新
  
  删除方法:
  delete(object)
  1直接创建对象 然后删除
  2先查询再删除(推荐,可以做到级联删除)
  
  保存或删除方法
   saveorupdate()
  
  查询所有或者其他复杂查询
  用session.creatquery();  参数是hql查询语句  
  1使用HQL
  2使用sqlquery
  session.createsqlquery("sql查询")
  
  
  
   六持久化对象
   1持久化:将内存中的一个对象持久化到数据库中
   2持久化类: 一个java对象与数据库中的表建立了映射关系,那么这个持久化类在hibernate中成为
   3持久类的编写规则
   Ⅰ需要一个无参构造函数  因为hibernate底层依赖反射
       反射 IOC 
       Class class = Class.forName(className);
       Object object = class.newInstance(); // 只能调用无参构造函数   
   Ⅱ
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
   
