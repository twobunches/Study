一:可变参数 object ...args   三个点代表可变的参数,即数量不固定
当函数的参数数量不固定的时候,可以用这种可变参数
怎么在函数里引用这种可变参数?
可变参数可以看成是数组,在函数内部可以用数组依次调用参数列表从左往右的的参数

当可变参数的类型也不固定时,可以使用object作为类型
比如有一个函数定义  void Plus(object ...args,int a,int b){
    

}
这里的object ...args可以传入不限制数量的参数,然后在内部用数组引用

比如 args[0]代表可变参数列表传入的第一个参数  args[1]...以此类推
很明显 用一个循环可以遍历
for(int i=0;i<args.length;i++){

  args[i]...

}

调用函数时 比如 Plus("abc",123,'a',1,2)   前面三个都是可变参数,后面两个是固定的参数
在DBUtil的 queryRunner类的query方法内部就是用了可变参数,因为每次插叙你的sql语句的?数量不固定,类型也不固定
ps对象的setObject方法可以在类型不确定的情况下给?设置值

二 mete data 元数据
描述数据的数据

三种类型
数据库元数据 databasemetadata
参数元数据  parameterdata类 用以描述参数的元数据
比如preparestatement对象以一个带问号sql语句构造对象,可以使用getparametermetadata来得到这个对象参数的信息
metadata md = ps.getParametermetadata() //得到ps对象的参数元数据对象
md.metadataCount();//得到参数的个数,也就是sql中?的个数 
结果集元数据  resuktset metadata 


接口的匿名实现类写法  new 接口名(){  }
<T>  泛型可以放在类的申明中,也可以放在方法的申明中

三:MVC设计模式
M  model 模型层 javabean 封装数据
v视图层 展示给用户的
c controller serclet 处理请求跳转

当我们使用数据库连接池和DButil时并不是意味着我们不需要使用jdbc的jar包了
只是说我们要写的代码封装进了dbcp和dbutil里面了,无论连接那个数据库都要导入对应的jdbcjar包
只是说数据库连接池和dbutil简化了我们的代码,其实就是封装了我们需要写的代码,而这个代码还是要依赖于不同数据库的
也可以仔细思考,不论是dbcp还是c3p0 它们都要设置四个参数,其中就有数据库驱动器类型 不同类型对应了不同的jar包
dbcp帮我们简化了 创建连接的操作  dbutil帮我们简化了与数据库交互的操作 
数据库连接池的底层依然要依赖于jdbc的jar包来完成与数据库的连接 

throw exception :抛出异常可以将异常抛给可以异常所在的方法,注意假如在接口里面的方法没有抛出异常,而在实现类里面抛出了异常,那么接口里的方法定义也要改变
假如接口里面没有定义抛出某个异常,那么实现类则不能抛出异常,只能是由try catch


null字符串和空字符串的区别
String a = null;
String a = "";
null字符串在拼接的时候会带上null,所以最好使用空字符串

javascript里面的函数定义形参的时候不需要类型,本来也没有类型 也就是不需要var 这个申明 直接给形参名字就好
window对象的location属性可以引用location对象 location对象用于设置或得到当前浏览器的url的各个部分 
比如location.href可以设置当前浏览器的完整url 使用get方法传递参数需要在url后面跟上问号然后以值对的形式写参数
比如url?key=values
要注意在js里面双引号引上的东西不再是变量,但是在html里面,不能用java的思想 比如"${}" 在双引号类有个el表达式 并不意味着EL不能正常解析
在html页面中 只管解析和呈现,不会考虑双引号这种,在html中的EL表达式不论在双印号还是单引号内都能正常解析
因为EL 和JSTL是在jsp页面转化为servlet的时候完成解析的,并且html里面的双引号也没有特殊意义(不包括js代码)

Windows的confirm()方法可以在浏览器弹出一个选择框












 
