一:可变参数 object ...args   三个点代表可变的参数,即数量不固定
当函数的参数数量不固定的时候,可以用这种可变参数
怎么在函数里引用这种可变参数?
可变参数可以看成是数组,在函数内部可以用数组依次调用参数列表从左往右的的参数

当可变参数的类型也不固定时,可以使用object作为类型
比如有一个函数定义  void Plus(object ...args,int a,int b){
    

}
这里的object ...args可以传入不限制数量的参数,然后在内部用数组引用

比如 args[0]代表可变参数列表传入的第一个参数  args[1]...以此类推
很明显 用一个循环可以遍历
for(int i=0;i<args.length;i++){

  args[i]...

}

调用函数时 比如 Plus("abc",123,'a',1,2)   前面三个都是可变参数,后面两个是固定的参数
在DBUtil的 queryRunner类的query方法内部就是用了可变参数,因为每次插叙你的sql语句的?数量不固定,类型也不固定
ps对象的setObject方法可以在类型不确定的情况下给?设置值

二 mete data 元数据
描述数据的数据

三种类型
数据库元数据 databasemetadata
参数元数据  parameterdata类 用以描述参数的元数据
比如preparestatement对象以一个带问号sql语句构造对象,可以使用getparametermetadata来得到这个对象参数的信息
metadata md = ps.getParametermetadata() //得到ps对象的参数元数据对象
md.metadataCount();//得到参数的个数,也就是sql中?的个数 
结果集元数据  resuktset metadata 


接口的匿名实现类写法  new 接口名(){  }
<T>  泛型可以放在类的申明中,也可以放在方法的申明中

三:MVC设计模式
M  model 模型层 javabean 封装数据
v视图层 展示给用户的
c controller serclet 处理请求跳转

当我们使用数据库连接池和DButil时并不是意味着我们不需要使用jdbc的jar包了
只是说我们要写的代码封装进了dbcp和dbutil里面了,无论连接那个数据库都要导入对应的jdbcjar包
只是说数据库连接池和dbutil简化了我们的代码,其实就是封装了我们需要写的代码,而这个代码还是要依赖于不同数据库的
也可以仔细思考,不论是dbcp还是c3p0 它们都要设置四个参数,其中就有数据库驱动器类型 不同类型对应了不同的jar包
dbcp帮我们简化了 创建连接的操作  dbutil帮我们简化了与数据库交互的操作 
数据库连接池的底层依然要依赖于jdbc的jar包来完成与数据库的连接 

throw exception :抛出异常可以将异常抛给可以异常所在的方法,注意假如在接口里面的方法没有抛出异常,而在实现类里面抛出了异常,那么接口里的方法定义也要改变
假如接口里面没有定义抛出某个异常,那么实现类则不能抛出异常,只能是由try catch


null字符串和空字符串的区别
String a = null;
String a = "";
null字符串在拼接的时候会带上null,所以最好使用空字符串

javascript里面的函数定义形参的时候不需要类型,本来也没有类型 也就是不需要var 这个申明 直接给形参名字就好
window对象的location属性可以引用location对象 location对象用于设置或得到当前浏览器的url的各个部分 
比如location.href可以设置当前浏览器的完整url 使用get方法传递参数需要在url后面跟上问号然后以值对的形式写参数
比如url?key=values
要注意在js里面双引号引上的东西不再是变量,但是在html里面,不能用java的思想 比如"${}" 在双引号类有个el表达式 并不意味着EL不能正常解析
在html页面中 只管解析和呈现,不会考虑双引号这种,在html中的EL表达式不论在双印号还是单引号内都能正常解析
因为EL 和JSTL是在jsp页面转化为servlet的时候完成解析的,并且html里面的双引号也没有特殊意义(不包括js代码)

Windows的confirm()方法可以在浏览器弹出一个选择框
基础注意:
1:首先Arrays的tostring方法将数组元素整合成一个字符串,格式形如[元素1,..],但是要注意元素与元素之间用的逗号+空格分隔开的
也就是如如果用,将这个字符串拆分,那么得到的元素从第二个开始它们前面都会自带一个空格,这一点要注意
2:一个带空格的字符串和不带空格的字符串肯定是不同的  比如"  adb"和"abc" 很明显空格也是有效的字符..
3:sacnner的 next和nextxxx 方法 忽略输入前的空格和tab 然后以空格 tab 回车作为结束标志
      而nextLine()方法不会忽略输入前的空格和tab,并且只以回车作为结束标志, nextLine()方法只识别Enter键作为结束.
      因此nextLine方法可以得到带空格的字符串,next方法只能得到不带空格的字符串


分页功能:
物理分页:
查询数据的时候只查询一页的数据,然后就返回

逻辑数据:
一口气把所有数据查询出来,然后放置在内存中

数据库的分页查询
limit x  offset  y  或者 limit y,x 
 限制查询几条数据
 offset 是偏移量 从查出来的总结果的开始 偏移多少数量 就是忽略前面y条数据 也可以理解为从总结果的y+1条开始显示 
 
 x是每次要查多少条  y是指偏移多少  假如要从第一条开始查 很明显y=0  不便宜
 y = 要开始的地方-1 y=(页数-1)*x
 
 接口里面定义的变量一律都是final和static类型的静态常量,不可改变
 
 
 在query()方法里面,如果查询的不是一行行元组,而是比如平均数之类的,那么需要传入的实现类是 ScalarHandler()
 当然还是那句话想要返回的是类  list 还是基本数据类型 可以自己写rshandel的实现类   在使用这个实现类后 query返回的值是一个Long类型的(long的封装类)
 
 
 当我们要返回的数据是很多类型的时候,要优先考虑返回的就是一个javabean 其实就是一个java类 这个类是通用的
 
 
 EL表达式能取出javabean的私有成员的值
 
 
 四关于mysql数据库最大连接数的问题
 mysql数据库(不管是哪种数据库) 都有一个默认的最大连接数
 当超过这个连接后会显示拒绝连接,
 我们使用的连接池 是指当我们初始化c3p0或者dbcp的连接池 会预先创建默认个数的连接放在连接池类
  如果我们在一个web项目里面频繁地创建不同的连接池,那么会很快占用完mysql的最大连接数
   解决方案:1:如果实在代码中需要频繁创建连接池,那么将连接池的初始连接个数设置小点,设置会2或者3,不够的话它们有自动扩容
                这样就可以创建很多个连接池   
                在c3p0的xml文件中配置init...和minconnection
   
            2:设置mysql的最大连接数 set global max_connections=1000//设置最大连接数1000
            3:尽量不要频繁创建连接池,可以所有方法共享一个连接池,那么在Dao类的静态代码快中 创建连接池对象,那么所有方法只有一个连接池
            也就不存在创建多个连接的的事情发生 ,比如一个Dao申明一个公用的连接池,也就是同一张表的方法使用一个池子
            怎么公用一个池子呢?
            在Dao的实现类中 所有方法都只使用一个静态变量
            在普通方法中是可以随意使用静态或非静态变量的
            在Dao中创建静态的连接池对象是最好的处理方法
            4:要注意的是连接池的close()指的是让某个连接回到池子里而不是释放,连接池空闲的连接由连接池自己释放
            5:c390xml里面有个maxIdleTime 当连接超过指定时间后没有使用的话就会还给mysql,然后连接池中的连接数目会减少到设置的min数量
            6:<property name="initialPoolSize">2</property>   初始数量
             <property name="maxIdleTime">5</property>          连接的最大空闲时间,如果超过则会给数据库
              =  <property name="maxPoolSize">1000</property>  池子里面的最大个数
                <property name="minPoolSize">2</property>       池子里面最小的个数
            
                
 
 
 
 
 
 
 
 
 
 
 
 
 
